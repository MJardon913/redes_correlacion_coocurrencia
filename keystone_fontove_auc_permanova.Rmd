---
title: "keystone_fontove_auc_permanova"
output: html_document
date: '2022-10-03'
---
#Datos
##Muestras 

```{r}
getwd()
setwd("~/proyecto/redes_correlacion_coocurrencia")
#Se cargan los datos de las muestras

data <- read.table("table.from_chile.txt", header = FALSE , sep= "" )

#Asumiendo que los otus pueden etiquetarse con números de 0 en adelante, y que la red puede describirse con estas etiquetas, se fijan
data$enum <- 0:(dim(data)[1]-1)
head(data)
```

##Separación de las muestras por metadatos

```{r}
#La separación es por etapa fenológica; los siguientes vectores describen qué muestras corresponden a cada etapa
produccion <- c("V1","V6")
plantacion <- c("V7")
desarrollo <- c("V2", "V3", "V4" ,"V5")

data_prod <- data[,produccion]
data_plan <- data[,plantacion]
data_des <- data[,desarrollo]

```
##Red

```{r}
#Se carga la red
red <- read.csv("networks/chile_species_raw_network.csv")
red = red[,1:3]
head(red)
dim(red)
#Este es el vector de etiquetas de los otus como nodos en la red
otus <- data$enum
```
##Cálculo de medidas de centralidad

#Grado



```{r}

# Dar un Otu numerico
# variables son un OTU y un dataframe (red)
# red tiene tres columnas, dos de otus y una de coeficente
# funcion Ogrado_TOU_en_df

deg_otu <- function(df , otu){
  
  x_1 <- 1
  suma_otu <- 0
  
  while (x_1 <= dim(df)[1] && df[x_1, 1] != otu ){x_1 = x_1 + 1}
  
 
  
  while (x_1 <= dim(df)[1] && df[x_1 ,1] == otu ){ suma_otu = suma_otu + df[x_1 ,3]
  
  x_1 = x_1 + 1}
  
return(suma_otu)}
```

```{r}

deg <- function(df , nodes){
  #df debe ser un data frame cuyas primeras dos columnas representan los pares de otus, sin redundancias, y la tercera es el peso de la arista
  #nodes es el vector de etiquetas ordenadas de los otus, y con cuyo orden se pueda ordenar las primeras dos columnas de df
  
  colnames(df) <- c("taxon1","taxon2","weight")
  df <- df[order(df[,"taxon1"]),]
  df_2 <- df[order(df[,"taxon2"]),]
  
  vec_deg <- c()
  
  
  x_1 <- 1
  x_2 <- 1
  
  for (i in 1:length(nodes)){
    suma_otu <- 0
    
    while (x_1 <= dim(df)[1] && df[x_1 , "taxon1"] == nodes[i] ){ suma_otu = suma_otu + df[x_1 ,"weight"]
  
  x_1 = x_1 + 1}
    
    while (x_2 <= dim(df)[1] && df_2[x_2 ,"taxon2"] == nodes[i] ){ suma_otu = suma_otu + df_2[x_2 ,"weight"]
  
  x_2 = x_2 + 1}
    
    vec_deg = c(vec_deg , suma_otu)
    }
    
    
  
  return(cbind.data.frame(as.data.frame(otus),as.data.frame(vec_deg)) )
}

```

```{r}


grados <- deg(red, otus)
head(grados)
dim(grados)
dim(data)
```







```{r}
#Se agrega a nuestros datos el grado de los otus
data_deg <- cbind(data, grados$vec_deg)
data_prod_deg <- cbind(data_prod ,grados$vec_deg)
data_plan_deg <- cbind(data_plan ,grados$vec_deg)
data_des_deg <- cbind(data_des ,grados$vec_deg)
```
```{r}
#
data_deg <- data_deg[order(data_deg[,dim(data_deg)[2]], decreasing = TRUE),]
data_prod_deg <- data_prod_deg[order(data_prod_deg[,dim(data_prod_deg)[2]], decreasing = TRUE),]
data_plan_deg <- data_plan_deg[order(data_plan_deg[,dim(data_plan_deg)[2]], decreasing = TRUE),]
data_des_deg <- data_des_deg[order(data_des_deg[,dim(data_des_deg)[2]], decreasing = TRUE),]
```
```{r}
auc <- function(df_deg){
  sm_p <- 0
  for (i in 1:dim(df_deg)[1]) {
  f_i = df_deg[i,dim(df_deg)[2]]
  if (f_i >= 0){sm_p = sm_p + f_i}
  else{sm_p = sm_p - f_i}
}

return(sm_p)}
```

```{r}
auc_percent <- function(df_deg, propo){
  i <- 1
  sum_par <- 0
  #c <- c() 
  while(i <= dim(df_deg)[1] && sum_par < propo) {
    #c <- c(c,i)
    g_i = df_deg[i,dim(df_deg)[2]]
    sum_par = sum_par + g_i
    i = i+1
  }
  return(i)
}
```


```{r}
area <- auc(data_by_deg)
c_auc5_percent <- c()
for (x in 1:20){
  c_auc5_percent = c(c_auc5_percent,auc_percent(data_by_deg, (area/20)*x))
  print(auc_percent(data_by_deg, (area/20)*x))
}
```


```{r}
library(vegan
        )

data_by_deg_5per <- data_by_deg[1:133,1:7]
bc_dist <- vegdist(t(data_by_deg_5per), method = "bray")

```


```{r}

```


